

# 基于conntrack mark标记的源进源出标记方案

```
               => 线路1  
             /
 PC  =>  主路由            .... => 目标主机
             \
                => 线路2
```

上图，当主路由存在，多线路均衡负载时，可能存在两条路径

```
PC => 主路由 => 线路1 => .... => 目标主机
PC => 主路由 => 线路2 => .... => 目标主机
```

对于同一个会话，应该希望PC => 目标主机的路径是固定的，这样才不容易出问题，如果两条路都可以在哦，在TCP握手阶段

```
SYN :     PC => 线路1(10.10.10.1) => 目标主机(看到PC的IP是10.10.10.1)
SYN+ACK : PC <= 线路1(10.10.10.1) <= 目标主机(看到PC的IP是10.10.10.1)
ACK :     PC => 线路2(10.10.10.2) => 目标主机(看到PC的IP是10.10.10.2)
```

不能确定哪个线路发送数据包出去，因为在iproute做均衡负载时，发包是按权重的。

对于一个链接，conntrack 会记录它的状态

- new
- established
- related

我们主要关注的 new 和 established，

当一条连接第一个数据包穿过防火墙, conntrack 会新建一个条目，记录这条连接，并且此时状态是 new，它只有一个方向看到流量。

当反向的数据包穿过防火墙后，new 状态转变成 established 状态，这条连接两个方向都看到了流量。

conntrack 是可以对条目进行标记的， ct mark，而这个ct mark 又可以从conntrack条目中获取，然后给数据包打上标记

# 思路

第一个数据包从哪个接口收到的，建立链接后，后续转发的数据包一定要从该接口发出去。

当链接还处于 new 状态时，说明，这条链接可能由3个地方产生

- 从内部发往外部网络的
- 由路由器本机发往外部/内部网络的
- 由外部网络发起的连接

当状态已转换成 established ，可能：

- 回复外网的请求
- 访问外部网络得到了对方的回复

根据 防火墙的各个检查点（hook）来考虑，哪里适合标记ct mark，哪里适合从ct mark中恢复标记到数据包的mark

多线路均衡负载对于路由器本身访问网络也是生效的。

# 打标原则

有两种标记：

- 一种是存在数据包中的，用于策略路由判断的标记，用 meta mark 表示
- 另一种是存在conntrack条目中的，与连接记录相关，这个条目会持续存在一段时间，用 ct mark 表示

原则：

- 在状态为new时，过路由查找后应打 **ct mark** 以分类连接，同一类的连接应确定相同的寻路策略。
- 在状态进一步转换成 established 后，每次过路由前，应从conntrack 中取出 **ct mark** 设置数据包 **meta mark** ，通过策略路由匹配 **fwmark** 影响路由查找结果。

# 第一个合法穿过防火墙的数据包，针对contrack 记录打 ct mark

根据 netfilter hook 对应的几个检查点，状态为 **NEW** 的数据包，有三条路径

```
路由主机本地 => output => 路由查找 => postrouting => 加入目标接口发送队列
接收队列 => preruoting => 路由查找 => forward => postrouting => 加入目标接口发送队列
接收队列 => prerouting => 路由查找 => input => 发往本机
```

output 这个位置还没路由查找，不能确定发送接口，不适合打 **ct mark**

forward 或者 postrouting 位置都 **适合对连接进行ct mark 打标** ，

这两个位置发现的 NEW 数据包，同时可以看见数据包从哪个网口发出，已经确定了发送接口 **oif/oifname** ，可以通过匹配 **oif/oifname** 区分标记，

```
路由器本地流量 => output   =>
                               postrouting
路由器转发流量 => forward  =>
```

转发流量在forward 或者 postrouting 经过了路由查找，确定发送接口，这两个地方都可以打 **ct mark**

input 位置 适合针对 **主动从外网访问的流量ct mark打标** ，此时根据 **iif** 判定流量流入口

| hook点      | ct state | 可否标记ct mark | 备注                         |
| ----------- | -------- | --------------- | ---------------------------- |
| prerouting  | new      | NO              | 未路由，不能确定发送接口     |
| input       | new      | YES             | 外网访问本机的流量标记       |
| forward     | new      | YES             | 转发流量标记                 |
| output      | new      | NO              | 未路由，不能确定发送接口     |
| postrouting | new      | YES             | 本地流量与转发流量打标汇聚点 |

# 后续的数据包，针对数据包的meta mark

当第一个数据包通过防火墙，状态为 new 时，已经在conntrack 建立了条目，并且打上了 ct mark 标记，那么对于有标记的连接，应该在路由以前，将ct mark标记应用到数据包的**meta mark**

```
output => 路由查找 => postrouting => ...
prerouting => 路由查找 ..
```

可以看到，有两个位置位于路由查找之前的，prerouting 和 output

在 output 处，状态为 established，是已建立的链接，它需要“源进源出”，路由前设置成 **meta mark** 结合策略规则以影响路由查找

在prerouting 处，established 状态的链接，可能是发往本地，也可能是做转发的，这里也需要打上数据包的mark影响它的路由查找

但是一旦在prerouting处打上了mark，将查找完特定的路由表，如果这个路由表没有通往本地的路由，可能是一个错误，有3种处理方案

- **ip rule** 设定策略更具体，应该满足2个条件，mark匹配和不含本地ip
- 在不同的路由表，都加上通往本地的路由
- ip rule 优先查找符合本地的路由，再查找其他路由



| hook点      | ct state    | 是否适合应用meta mark | 备注                                               |
| ----------- | ----------- | --------------------- | -------------------------------------------------- |
| prerouting  | established | YES                   | 路由前设置meta mark用于被策略路由规则匹配          |
| input       | established | NO                    | 已经过路由查找                                     |
| forward     | established | NO                    | 已经过路由查找                                     |
| output      | established | YES                   | 本机发出的流量设置meta mark 用于被策略路由规则匹配 |
| postrouting | established | NO                    | 已经过路由查找                                     |





# 打标规则应该设置在哪个优先级的chain中？

要修改ct状态，必须ct条目的操作已经生效了（创建、更新），在优先级-200，ct状态会被处理

打 **ct mark** 必须在优先级低于 -200 的链，优先级关键字 *mangle* 的数值是-150，适用

恢复 **meta mark** 也要等 ct 状态更新了才应用操作，统一在优先级为 *mangle* 的链操作

# 路由表(ip route)与路由策略(ip  rule)

单纯对连接进行分类标记 **ct mark**，他并没有直接影响到路由查找。

实际需要路由策略匹配 **fwmark** (也就是nftables给数据包打的 **meta mark**) 以确定查找哪一张路由表

有三张特殊的路由表，local main default

local表记录了网络接口配置的IP和IP广播地址的路由，它们应该最先无条件被查找



# 配置测试

```
# 两个外网接口基础信息,以及lan网络接口信息
wan1: 192.168.1.10  网关 192.168.1.1 路由表
wan2: 192.168.2.10  网关 192.168.2.1 
lan: 192.168.10.1
```

fwmark 分配

```
wan1   2
wan2   3
```

需要从wan1出去的连接打上编号为2的标记，3对应的是wan2



## 路由表分配

```
# /etc/iproute2/rt_tables
251     wan1
252     wan2

255     local
254     main
253     default
0       unspec
```
路由表的最多有256张(0-255)，其中254 255默认被系统使用。

wan1 的默认路由设置在编号为251的路由表，路由表别名为wan1

wan2 的默认路由设置在编号为252的路由表，路由表别名为wan2


路由表最终是个数字，用rt_tables让它可读性增强


### 设置wan1路由表

```
ip route add 192.168.1.0/24  table wan1 dev wan1 
ip route add default via 192.168.1.1 table wan1  dev wan1 
```

### 设置wan2路由表

```
ip route add 192.168.2.0/24  table wan2 dev wan2
ip route add default via 192.168.2.1 table wan2  dev wan2
```

### 设置默认的表main（编号254）

```
ip route add 192.168.10.0/24 table main dev lan
ip route add 192.168.1.0/24  table main dev wan1 
ip route add 192.168.2.0/24  table main dev wan2
ip route add default scope global \
	nexthop via 192.168.1.1 dev wan1 weight 1 \
	nexthop via 192.168.2.1 dev wan2 weight 2 \
```

配置默认路由表均衡负载,wan1和wan2的发送流量比例是1:2



## 策略分配

**ip rule** 命令可以设置路由的查找策略，每一条规则由3部分组成

- 规则的优先级
- 匹配条件
- 匹配成功后的动作(跳转到特定的规则重新匹配，查找路由表)


priority数值越小，优先级越高，规则越先被匹配

如果在对应的路由表中没有找到相关的路由，则继续遍历规则

如果没有满足规则匹配条件则继续下一条。



### 优先级分配

- 0 查找local
- 251 满足 fwmark 1 时查找table 251
- 252 满足 fwmark 2 时查找table 252
- 253 








nftables 设置，eth0 和 eth1是两个外网的接口

```
# /etc/nftables.conf
table inet mangle {
        chain prerouting {
                type filter hook prerouting priority mangle; policy accept;
                ct state established meta mark set ct mark counter comment "已建立链接的ct标记恢复"
        }

        chain input-ct-mark {
                type filter hook input priority mangle; policy accept;
                iifname "wan1 ct state new ct mark set 2 counter  comment "eth0分流ct标记"
                iifname "wan2" ct state new ct mark set 3 counter comment "eht1分流ct标记"
        }

        chain postrouting-ct-mark {
                type filter hook postrouting priority mangle; policy accept;
                oifname "wan1" ct state new ct mark set 2 counter packets 3418 bytes 372630 comment "wifi分流ct标记"
                oifname "wan2" ct state new ct mark set 3 counter packets 245 bytes 42803 comment "zx3分流ct标记"
        }

        chain output {
                type filter hook output priority mangle; policy accept;
                ct state established meta mark set ct mark counter comment "已建立链接的ct标记恢复"
		}

```









