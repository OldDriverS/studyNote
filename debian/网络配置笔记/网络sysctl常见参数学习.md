# 结合gpt的问答理解学习ip-sysctl 常见的一些参数


[内核文档ip-sysctl](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/networking/ip-sysctl.rst)

下面的值都是位于 `net.ipv4` 下的选项，例如

```
net.ipv4.ip_forward
```

对应proc的路径是 `/proc/sys/net/ipv4/`

设置选项可以通过 `sysctl` 命令调整。

```bash
systcl net.ipv4.ip_forward = 1
```

也可以编辑 `/etc/sysctl.conf` ，通过

```
sysctl -p
```
应用配置


# 路由转发相关

## ip_forward

布尔值，可选的值:   

- 0

- 1

控制接口是否允许转发，这是控制三层转发的，一般路由器需要开启

```bash
net.ipv4.ip_forward = 1
```

## forwarding

在此接口上启用IP转发，控制某个接口受到的数据包可以被转发。

他可以是这样的

```bash
net.ipv4.conf.接口名称.forwarding = 1
net.ipv4.conf.all.forwarding = 1
```

`ipv4.conf.all` 是针对 所有网卡都应用的配置。


## mc_forwarding

和forwarding的功能类似，这是控制组播流量的转发。

如果没用iptv之类的组播，一般设置成0

```
net.ipv4.conf.all.mc_forwarding = 0
```

## rp_filter

rp_filter用于控制网络包的源地址验证。它有以下三个取值：

- 0：不进行源地址验证。
- 1：启用严格模式，即RFC3704中定义的严格反向路径。每个传入的数据包都会与FIB（Forwarding Information Base）进行比较，如果接口不是最佳反向路径，则数据包检查将失败。默认情况下，失败的数据包会被丢弃。
- 2：启用宽松模式，即RFC3704中定义的宽松反向路径。每个传入的数据包的源地址也会与FIB进行比较，如果源地址不能通过任何接口到达，则数据包检查将失败。

RFC3704中的建议做法是启用严格模式，以防止DDos攻击中的IP欺骗。如果使用非对称路由或其他复杂路由，则建议使用宽松模式。

在进行源地址验证时，会使用conf/{all,interface}/rp_filter中的最大值。

默认值为0。需要注意的是，某些Linux发行版在启动脚本中启用了rp_filter。





## accept_source_route

布尔值，可选值

- 0
- 1

使用SRR选项接受数据包。

conf/all/accept_source_route 也必须设置为TRUE才能接受接口上带有SRR选项的数据包

默认情况，终端主机是设置成true而路由器要设置成false。

> GPT:数据包中如何包含源路由选项？SRR是什么协议？

源路由选项是一种IP数据包的选项，它允许发送方指定数据包的路由路径，而不是让路由器根据自己的路由表进行路由。在IP数据包中，源路由选项是一个可选的IP头部字段，它包含了一系列的IP地址，这些地址指定了数据包应该经过的路由器。

在IPv4中，源路由选项是通过在IP数据包头部中添加一个选项字段来实现的。该选项字段包含了一个指示源路由选项的标志位、一个指示源路由选项长度的字段、以及一系列的IP地址，这些IP地址指定了数据包应该经过的路由器。当路由器收到一个带有源路由选项的数据包时，它会按照源路由选项中指

> GPT:详细列出这个选项字段的格式

IPv4数据包中的源路由选项字段格式如下：

| 1字节 | 1字节 | 1字节 | 1字节 | 可变长度 |
|-------|-------|-------|-------|----------|
|  0x83 |  长度 |  指针 |  地址 |  地址... |

其中，各字段的含义如下：

- 第1字节：选项类型，固定为0x83，表示这是一个源路由选项。
- 第2字节：选项长度，表示整个选项字段的长度，包括第1字节和第2字节。因为地址的数量是可变的，所以选项长度也是可变的。
- 第3字节：指针，表示下一个要填写的地址在选项字段中的偏移量。初始值为4，表示下一个要填写的地址是选项字段中的第5个字节。
- 第4字节：第一个地址，表示数据包应该经过的第一个路由器的IP地址。
- 可变长度：后续地址，表示数据包应该经过的其他路由器的IP地址。地址的数量和长度由选项长度字段指定。

需要注意的是，源路由选项字段的长度不能超过40字节，否则会被视为无效选项。此外，源路由选项只能在本地网络中使用，因为在Internet中使用源路由选项可能会导致安全问题。






# 邻居相关

## proxy_arp

布尔值，arp代理，可选值：
- 0、false
- 1、true

如果 conf/{all,interface}/proxy_arp 中至少有一个设置为TRUE，则将启用接口的proxy_arp，否则将禁用它。

至少是 `ipv4.conf.all.proxy_arp` 或者 `ipv4.conf.all.网络接口名.proxy_arp` 设置为真才会启用。否则是禁用arp代理。


## arp_filter 

布尔值，可选值：

- 0 默认值
- 1

`arp_filter`是一个布尔类型的内核参数，用于控制Linux系统如何响应ARP请求。ARP（Address Resolution Protocol）是一种用于将IP地址映射到MAC地址的协议，它在局域网中广泛使用。

当`arp_filter`设置为1时，允许在同一子网上拥有多个网络接口，并根据内核是否将数据包从ARP'd IP路由到该接口来回答每个接口的ARP请求。因此，必须使用基于源地址的路由才能使其正常工作。换句话说，它允许控制哪个网卡（通常只有一个）将响应ARP请求。

当`arp_filter`设置为0时（默认值），内核可以使用其他接口的地址响应ARP请求。这可能看起来不正确，但通常是有意义的，因为它增加了成功通信的机会。在Linux上，IP地址是由整个主机拥有的，而不是由特定接口拥有的。只有在更复杂的设置（如负载平衡）中，这种行为才会引起问题。

如果`conf/{all,interface}/arp_filter`中至少有一个设置为TRUE，则将启用接口的`arp_filter`。

## arp_announce

`arp_announce`用于定义在ARP请求中发送本地源IP地址时的限制级别。ARP（Address Resolution Protocol）是一种用于将IP地址映射到MAC地址的协议，它在局域网中广泛使用。

`arp_announce`有三个可选值：

- 0：（默认值）使用任何配置在任何接口上的本地地址。
- 1：尝试避免不在该接口目标子网中的本地地址。当通过该接口可达的目标主机要求ARP请求中的源IP地址是其接收接口上配置的逻辑网络的一部分时，此模式很有用。当我们生成请求时，我们将检查包括目标IP的所有子网，并在源地址属于这样的子网时保留源地址。如果没有这样的子网，我们将根据级别2的规则选择源地址。
- 2：始终使用最佳的本地地址。在此模式下，我们忽略IP数据包中的源地址，并尝试选择我们喜欢与目标主机通信的本地地址。通过查找所有包括目标IP地址的传出接口上的子网的主要IP地址来选择此类本地地址。如果找不到合适的本地地址，我们将选择传出接口或所有其他接口上的第一个本地地址，希望我们将收到对我们的请求的回复，有时甚至不管我们宣布的源IP地址是什么。

使用`conf/{all,interface}/arp_announce`中的最大值。

增加限制级别可以增加从解析目标接收答案的机会，而降低级别则会公布更多有效的发送者信息。


## arp_ignore

`arp_ignore` 用于定义在响应接收到的ARP请求以解析本地目标IP地址时发送回复的不同模式。

`arp_ignore`有以下可选值：

- 0：（默认值）为任何配置在任何接口上的本地目标IP地址回复。
- 1：仅在接收接口上配置了目标IP地址时回复。
- 2：仅在接收接口上配置了目标IP地址，并且发送者的IP地址都是该接口上同一子网的一部分时回复。
- 3：不回复配置为范围为主机的本地地址，仅回复全局和链路地址的解析。
- 4-7：保留。
- 8：不回复任何本地地址。

当在{interface}上收到ARP请求时，将使用`conf/{all,interface}/arp_ignore`中的最大值。

这些选项允许管理员控制主机如何响应ARP请求，以及哪些地址可以公开。例如，如果管理员希望主机仅响应来自同一子网的ARP请求，则可以将`arp_ignore`设置为2。如果管理员希望主机完全忽略ARP请求，则可以将`arp_ignore`设置为8。

# ICMP相关

## icmp_echo_ignore_all

布尔值类型，可选值:

- 0
- 非0

设置成非0的值会忽略ping的请求。

```bash
net.ipv4.icmp_echo_ignore_all = 1
```



